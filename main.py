from groq import Groq
from fastapi import FastAPI
from pydantic import BaseModel
from fastapi.middleware.cors import CORSMiddleware
import uvicorn
from slowapi import Limiter
from slowapi.errors import RateLimitExceeded
import re , os 
from decoder import SentenceDetector
import asyncio
from dotenv import load_dotenv


load_dotenv()

client = Groq(
    api_key=os.getenv("GROQ_API_KEY"),
)
limiter = Limiter(key_func=lambda request: request.client.host)
user_settings = {}
detector = SentenceDetector()


class Settings(BaseModel):
    tone: str
    way: str
    reason: str


app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


buffer = ""
conversation_buffer = {}


class TextRequest(BaseModel):
    text: str


@app.post("/store_settings")
async def store_settings(settings: Settings):
    # Store the settings (this is just a mock, you could save to a database)
    user_settings['tone'] = settings.tone
    user_settings['way'] = settings.way
    user_settings['reason'] = settings.reason


@app.post("/rewrite")
async def rewrite_text(request: TextRequest):
    try:
        user = request.text
        tone = user_settings.get('tone', 'neutral')
        way = user_settings.get('way', 'polite')
        reason = user_settings.get('reason', 'Casual Writing')
        rewritten_text = decoder_ops(user, tone, way, reason)
        return {"rewrittenText": rewritten_text}
    except Exception as e:
        print(f"Error : {e}")
        return {"error": "An error occurred"}


@app.get("/get_rewritten_text")
async def get_rewritten_text():
    global buffer
    return_text = buffer
    buffer = ""
    return {"rewrittenText": return_text}


def decoder_ops(text, tone, way, reason):
    global conversation_buffer
    if detector.process_text(text):
        rewritten_text = get_rewritten_text_by_LLM(text, tone, way, reason)
        return rewritten_text
    return ""


def get_rewritten_text_by_LLM(text, tone, way, reason):
    global buffer
    global conversation_buffer
    mod_conversation_buffer = list(conversation_buffer.items())[:10]
    chat_completion = client.chat.completions.create(  # Using await here
        messages=[
            {
                "role": "user",
                "content": f""" You are a professional writer who has good knowledge of rewriting given text For Content Creation and for SEO Optimisation.
                                Your task is to rewrite the user written by by keeping in mind the context.
                                keep the genrated text with little elaboration and in {tone} tone and {way} strictly and only the next sentence or next few words not more than that.
                                **STRICTLY** Remeber its not a converation with you just you just have to rewrite the text.
                                Your response should be strictly only generated text and nothing else and important its not a conversation. 
                                don't mention anything like 'Here is the rewritten user text...'
                                also, you will be given some context of the latest previous written text by the user and response generated by you: {mod_conversation_buffer}
                                Remember that the user is writing for {reason} and add proper punctuation.
                                User Text  {text}""",
            }
        ],
        model="llama3-8b-8192",
    )

    rewritten_text = chat_completion.choices[0].message.content
    buffer += rewritten_text
    conversation_buffer[text] = rewritten_text
    print(conversation_buffer)
    return rewritten_text


if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)
